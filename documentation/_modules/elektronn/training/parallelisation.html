<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>elektronn.training.parallelisation &mdash; ELEKTRONN</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1rc',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/elektronnfavicon.ico"/>
    <link rel="top" title="ELEKTRONN" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/elektronn.png" border="0" alt="sampledoc"/></a>
</div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for elektronn.training.parallelisation</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># ELEKTRONN - Neural Network Toolkit</span>
<span class="c">#</span>
<span class="c"># Copyright (c) 2014 - now</span>
<span class="c"># Max-Planck-Institute for Medical Research, Heidelberg, Germany</span>
<span class="c"># Authors: Marius Killinger, Gregor Urban</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="c">#----------------------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="SharedMem"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedMem">[docs]</a><span class="k">class</span> <span class="nc">SharedMem</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utilities to share np.arrays between processes&quot;&quot;&quot;</span>
    <span class="n">_ctypes_to_numpy</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int8</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint8</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint16</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_byte</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ubyte</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_short</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ushort</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulong</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulonglong</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_float</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">_numpy_to_ctypes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_ctypes_to_numpy</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                <span class="n">_ctypes_to_numpy</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="SharedMem.shm2ndarray"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedMem.shm2ndarray">[docs]</a>    <span class="k">def</span> <span class="nf">shm2ndarray</span><span class="p">(</span><span class="n">mp_array</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Parameters</span>
<span class="sd">      ----------</span>
<span class="sd">      </span>
<span class="sd">      mp_array: a mp.Array</span>
<span class="sd">      shape:    (optional) the returned np.ndarray is reshaped to this shape, flat otherwise</span>
<span class="sd">      </span>
<span class="sd">      Returns</span>
<span class="sd">      -------</span>
<span class="sd">      </span>
<span class="sd">      array: np.ndarray</span>
<span class="sd">       That can be normally used but changes are reflected in shared mem</span>
<span class="sd">       </span>
<span class="sd">      Note: the returned array is still pointing to the sharedmem, data might be changed by another process!</span>
<span class="sd">      &quot;&quot;&quot;</span>
        <span class="c">#if not hasattr(mp_array, &#39;_type_&#39;):</span>
        <span class="c">#  mp_array = mp_array.get_obj()</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">SharedMem</span><span class="o">.</span><span class="n">_ctypes_to_numpy</span><span class="p">[</span><span class="n">mp_array</span><span class="o">.</span><span class="n">_type_</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">mp_array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c">#assert np.prod(shape)==result.size, &quot;Cannot reshape length-%s array to shape %s&quot;%(result.size, shape)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="SharedMem.ndarray2shm"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedMem.ndarray2shm">[docs]</a>    <span class="k">def</span> <span class="nf">ndarray2shm</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Parameters</span>
<span class="sd">          ----------</span>

<span class="sd">          np_array: np.ndarray</span>
<span class="sd">            array of arbitrary shape</span>
<span class="sd">          lock: Bool</span>
<span class="sd">            Whether to create a multiprocessing.Lock</span>

<span class="sd">          Returns</span>
<span class="sd">          -------</span>

<span class="sd">          handle: mp.Array:</span>
<span class="sd">            flat with data from ndarray copied to it</span>
<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">array1d</span> <span class="o">=</span> <span class="n">np_array</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_type</span> <span class="o">=</span> <span class="n">SharedMem</span><span class="o">.</span><span class="n">_numpy_to_ctypes</span><span class="p">[</span><span class="n">array1d</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">c_type</span> <span class="o">=</span> <span class="n">SharedMem</span><span class="o">.</span><span class="n">_numpy_to_ctypes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">array1d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">c_type</span><span class="p">,</span> <span class="n">array1d</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>
        <span class="n">SharedMem</span><span class="o">.</span><span class="n">shm2ndarray</span><span class="p">(</span><span class="n">result</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">array1d</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="SharedMem.puthandle"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedMem.puthandle">[docs]</a>    <span class="k">def</span> <span class="nf">puthandle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates new shared memory and puts it on the queue. Other sub-processes can write to it.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype: np.dtype</span>
<span class="sd">      Type of data to store in array</span>
<span class="sd">    shape: tuple</span>
<span class="sd">      Properties of shared mem to be created</span>
<span class="sd">    data: np.ndarray</span>
<span class="sd">     (optional) values to fill shared array with</span>
<span class="sd">    lock: Bool</span>
<span class="sd">      Whether to create a multiprocessing.Lock on the shared variable</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sharedmem handle: mp.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_type</span> <span class="o">=</span> <span class="n">SharedMem</span><span class="o">.</span><span class="n">_numpy_to_ctypes</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">c_type</span> <span class="o">=</span> <span class="n">SharedMem</span><span class="o">.</span><span class="n">_numpy_to_ctypes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)]</span>

        <span class="n">shm</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">c_type</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">SharedMem</span><span class="o">.</span><span class="n">shm2ndarray</span><span class="p">(</span><span class="n">shm</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">:</span>
            <span class="n">t_alloc</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">t_write</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;SharedMemAlloc </span><span class="si">%g</span><span class="s"> ms, WriteInitialData </span><span class="si">%g</span><span class="s"> ms&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">t_alloc</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">t_write</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">shm</span>

</div></div>
<div class="viewcode-block" id="Proc"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.Proc">[docs]</a><span class="k">class</span> <span class="nc">Proc</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  A *reusable* and *configurable* background process, that does the same job every time</span>
<span class="sd">  ``events[&#39;new&#39;]`` is set and signals that is has finished one iteration by setting ``events[&#39;ready&#39;]``</span>
<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mp_arrays</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_args</span><span class="p">,</span>
                 <span class="n">target_kwargs</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Proc</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_args</span> <span class="o">=</span> <span class="n">target_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_kwargs</span> <span class="o">=</span> <span class="n">target_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># shm &quot;wrapped&quot; as np.array-objs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">shm</span><span class="p">,</span> <span class="n">shp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mp_arrays</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SharedMem</span><span class="o">.</span><span class="n">shm2ndarray</span><span class="p">(</span><span class="n">shm</span><span class="p">,</span> <span class="n">shp</span><span class="p">))</span>

<div class="viewcode-block" id="Proc.run"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.Proc.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
                <span class="p">)</span>  <span class="c"># wait till host has fetched data from shm and demands new data from this proc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">target_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">target_kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
                    <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">r</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s">&#39;ready&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="p">)</span>  <span class="c"># signal host that task is done and data is ready in shm</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">:</span>
                    <span class="n">t_exec</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s">&#39;Executing Target and writing to shm </span><span class="si">%g</span><span class="s"> ms&#39;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">t_exec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="k">pass</span>

</div></div>
<div class="viewcode-block" id="BackgroundProc"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.BackgroundProc">[docs]</a><span class="k">class</span> <span class="nc">BackgroundProc</span><span class="p">(</span><span class="n">SharedMem</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">target</span><span class="p">,</span>
                 <span class="n">dtypes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">shapes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">n_proc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">target_args</span><span class="o">=</span><span class="p">(),</span>
                 <span class="n">target_kwargs</span><span class="o">=</span><span class="p">{},</span>
                 <span class="n">profile</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data structure to manage repeated background tasks by reusing a fixed number of *initially* created</span>
<span class="sd">    background process with the same arguments at every time. (E.g. retrieving an augmented batch)</span>
<span class="sd">    Remember to call ``BackgroundProc.shutdown`` after use to avoid zombie process and RAM clutter.</span>
<span class="sd">  </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">  </span>
<span class="sd">    dtypes:</span>
<span class="sd">      list of dtypes of the target return values</span>
<span class="sd">    shapes:</span>
<span class="sd">      list of shapes of the target return values</span>
<span class="sd">    n_proc: int</span>
<span class="sd">      number of background procs to use</span>
<span class="sd">    target: callable</span>
<span class="sd">      target function for background proc. Can even be a method of an object, if object\</span>
<span class="sd">    data is read-only (then data will not be copied in RAM and the new process is lean). If\</span>
<span class="sd">    several procs use random modules, new seeds must be created inside target because they\</span>
<span class="sd">    have the same random state at the beginning.</span>
<span class="sd">    target_args:  tuple</span>
<span class="sd">      Proc args (constant)</span>
<span class="sd">    target_kwargs: dict</span>
<span class="sd">      Proc kwargs (constant)</span>
<span class="sd">    profile: Bool</span>
<span class="sd">      Whether to print timing results in to stdout</span>
<span class="sd">  </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">  </span>
<span class="sd">    Use case to retrieve batches from a data structure ``D``:</span>
<span class="sd">  </span>
<span class="sd">      &gt;&gt;&gt; data, label = D.getbatch(2, strided=False,</span>
<span class="sd">      flip=True, grey_augment_channels=[0])</span>
<span class="sd">      &gt;&gt;&gt; kwargs = {&#39;strided&#39;: False, &#39;flip&#39;: True, &#39;grey_augment_channels&#39;: [0]}</span>
<span class="sd">      &gt;&gt;&gt; bg = BackgroundProc([np.float32, np.int16], [data.shape,label.shape],</span>
<span class="sd">      D.getbatch,n_proc=2, target_args=(2,), target_kwargs=kwargs, profile=False)</span>
<span class="sd">      &gt;&gt;&gt; for i in xrange(100):</span>
<span class="sd">      &gt;&gt;&gt;   data, label = bg.get()</span>
<span class="sd">  </span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">=</span> <span class="n">dtypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_proc</span> <span class="o">=</span> <span class="n">n_proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># index of next item to consume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mp_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">procs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dtypes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">shapes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">target</span><span class="p">(</span><span class="o">*</span><span class="n">target_args</span><span class="p">,</span> <span class="o">**</span><span class="n">target_kwargs</span><span class="p">)</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span> <span class="o">=</span> <span class="n">dtypes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n_proc</span><span class="p">):</span>  <span class="c"># create a list of mp-arrays for each process</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dtypes</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">puthandle</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mp_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">&#39;new&#39;</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">Event</span><span class="p">(),</span> <span class="s">&#39;ready&#39;</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">Event</span><span class="p">()})</span>

        <span class="k">for</span> <span class="n">shm</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mp_arrays</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">):</span>  <span class="c"># initialise the procs and give them their mp-arrays</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Proc</span><span class="p">(</span><span class="n">shm</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_args</span><span class="p">,</span> <span class="n">target_kwargs</span><span class="p">,</span>
                     <span class="n">profile</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">e</span><span class="p">[</span><span class="s">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<div class="viewcode-block" id="BackgroundProc.get"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.BackgroundProc.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This gets the next result from a background process and blocks until the corresponding proc</span>
<span class="sd">    has finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_proc</span>  <span class="c"># advance index of next item</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;ready&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;ready&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">shm</span><span class="p">,</span> <span class="n">shp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mp_arrays</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SharedMem</span><span class="o">.</span><span class="n">shm2ndarray</span><span class="p">(</span><span class="n">shm</span><span class="p">,</span> <span class="n">shp</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                          <span class="p">)</span>  <span class="c"># copy! Otherwise a proc will write to result</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">:</span>
            <span class="n">t_wait</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">t_write</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s">&#39;Waiting for subprocess </span><span class="si">%g</span><span class="s"> ms, converting to numpy </span><span class="si">%g</span><span class="s"> ms&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">t_wait</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">t_write</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BackgroundProc.shutdown"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.BackgroundProc.shutdown">[docs]</a>    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;**Must be called to free memory** if the background tasks are no longer needed&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">procs</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BackgroundProc.reset"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.BackgroundProc.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Should be called after an exception (e.g. by pressing ctrl+c) was raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="n">e</span><span class="p">[</span><span class="s">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="SharedQ"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedQ">[docs]</a><span class="k">class</span> <span class="nc">SharedQ</span><span class="p">(</span><span class="n">SharedMem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  FIFO Queue to process np.ndarrays in the background (also pre-loading of data from disk)</span>

<span class="sd">  procs must accept list of ``mp.Array`` and make items ``np.ndarray`` using ``SharedQ.shm2ndarray``,\</span>
<span class="sd">  for this the shapes are required as too. The target requires the signature::</span>

<span class="sd">     &gt;&gt;&gt; target(mp_arrays, shapes, *args, **kwargs)</span>

<span class="sd">  Whereas mp_array and shape are *automatically* added internally</span>
<span class="sd">  </span>
<span class="sd">  All parameters are optional:</span>

<span class="sd">  Parameters</span>
<span class="sd">  ----------</span>
<span class="sd">  </span>

<span class="sd">  n_proc: int </span>
<span class="sd">    If larger than 0, a message is printed if to few processes are running</span>
<span class="sd">  default_target: callable</span>
<span class="sd">    Default background proc callable</span>
<span class="sd">  default_args: tuple</span>
<span class="sd">    Default background proc and their parameters</span>
<span class="sd">  default_kwargs: dict</span>
<span class="sd">    Default background proc kwargs</span>
<span class="sd">  profile: Bool</span>
<span class="sd">    Whether to print timing results in terminal</span>

<span class="sd">  Examples</span>
<span class="sd">  ---------</span>

<span class="sd">  Automatic use:</span>

<span class="sd">    &gt;&gt;&gt; Q = SharedQ(n_proc=2)</span>
<span class="sd">    &gt;&gt;&gt; Q.startproc(target=, shape= args=, kwargs=)</span>
<span class="sd">    &gt;&gt;&gt; Q.startproc(target=, shape= args=, kwargs=)</span>
<span class="sd">    &gt;&gt;&gt; for i in xrange(5):</span>
<span class="sd">    &gt;&gt;&gt;   Q.startproc(target=, shape= args=, kwargs=)</span>
<span class="sd">    &gt;&gt;&gt;   item = Q.get() # starts as many new jobs as to maintain n_proc</span>
<span class="sd">    &gt;&gt;&gt;   dosomehtingelse(item) # processes work in background to pre-fetch data for next iteration</span>

<span class="sd">  &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_proc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">default_target</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">default_args</span><span class="o">=</span><span class="p">(),</span>
                 <span class="n">default_kwargs</span><span class="o">=</span><span class="p">{},</span>
                 <span class="n">profile</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>  <span class="c"># items of type [shm, shape, proc]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_proc</span> <span class="o">=</span> <span class="n">n_proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_target</span> <span class="o">=</span> <span class="n">default_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_args</span> <span class="o">=</span> <span class="n">default_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_kwargs</span> <span class="o">=</span> <span class="n">default_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile</span> <span class="o">=</span> <span class="n">profile</span>

<div class="viewcode-block" id="SharedQ.startproc"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedQ.startproc">[docs]</a>    <span class="k">def</span> <span class="nf">startproc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">dtypes</span><span class="p">,</span>
                  <span class="n">shapes</span><span class="p">,</span>
                  <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">target_args</span><span class="o">=</span><span class="p">(),</span>
                  <span class="n">target_kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Starts a new process</span>

<span class="sd">    procs must accept list of ``mp.Array`` and make items ``np.ndarray`` using ``SharedQ.shm2ndarray``,\</span>
<span class="sd">    for this the shapes are required as too. The target requires the signature::</span>

<span class="sd">       target(mp_arrays, shapes, *args, **kwargs)</span>

<span class="sd">    Whereas mp_array  and shape are *automatically* added internally</span>
<span class="sd">    &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">target_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_target</span>
        <span class="k">if</span> <span class="n">target_args</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">target_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_args</span>
        <span class="k">if</span> <span class="n">target_kwargs</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="n">target_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_kwargs</span>

        <span class="n">mp_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dtypes</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="n">mp_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">puthandle</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp_arrays</span><span class="p">,</span> <span class="n">shapes</span><span class="p">)</span> <span class="o">+</span> <span class="n">target_args</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">_args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">target_kwargs</span><span class="p">)</span>
        <span class="n">proc</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">mp_arrays</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">proc</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">:</span>
            <span class="n">t_start</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Start Process </span><span class="si">%g</span><span class="s"> ms&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t_start</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="SharedQ.get"><a class="viewcode-back" href="../../../elektronn.training.html#elektronn.training.parallelisation.SharedQ.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This gets the first results in the queue and blocks until the corresponding proc</span>
<span class="sd">    has finished. If a n_proc value is defined this then new procs must be started *before* to</span>
<span class="sd">    avoid a warning message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
        <span class="n">mp_arrays</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_proc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">len</span>
        <span class="k">if</span> <span class="n">missing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;WARNING: You should have started </span><span class="si">%i</span><span class="s"> new workes before Q.get()&quot;</span> <span class="o">%</span> <span class="n">missing</span>

        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">proc</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">shm</span><span class="p">,</span> <span class="n">shp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mp_arrays</span><span class="p">,</span> <span class="n">shapes</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SharedMem</span><span class="o">.</span><span class="n">shm2ndarray</span><span class="p">(</span><span class="n">shm</span><span class="p">,</span> <span class="n">shp</span><span class="p">))</span>

        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile</span><span class="p">:</span>
            <span class="n">t_join</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">t_conv</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Join </span><span class="si">%g</span><span class="s"> ms, Shared2Numpy </span><span class="si">%g</span><span class="s"> ms&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">t_join</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">t_conv</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

<span class="c">### Testing etc. ##############################################################################</span>
<span class="c"># Pre requisits</span></div></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">gc</span>
    <span class="kn">import</span> <span class="nn">h5py</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">():</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s">&#39;~/devel/data/MPI/raw_center_cube_mag1_v3.h5&#39;</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s">&#39;raw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">load</span><span class="p">()</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">lt</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;REAL LOAD TIME </span><span class="si">%.2f</span><span class="s">  sec&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lt</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">CPU</span><span class="p">():</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1160</span> <span class="o">*</span> <span class="mi">480</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">CPU</span><span class="p">()</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;REAL CPU TASK TIME </span><span class="si">%.2f</span><span class="s">  sec&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rt</span><span class="p">))</span>
    <span class="n">serial</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">rt</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">lt</span>
    <span class="n">D</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">IO</span><span class="p">(</span><span class="n">mp_array</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">load</span><span class="p">()</span>
        <span class="n">SharedQ</span><span class="o">.</span><span class="n">shm2ndarray</span><span class="p">(</span><span class="n">mp_array</span><span class="p">,</span> <span class="n">shape</span><span class="p">)[:]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;LOADED data in </span><span class="si">%.2f</span><span class="s">  sec&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">))</span>

<span class="c"># Automated Process Approach ################################################################</span>
<span class="c">#if False:</span>
<span class="c">#  bg = BackgroundProc([np.uint8], [(1160, 480)], load, n_proc=2)</span>
<span class="c">#  t00 = time.time()</span>
<span class="c">#  for i in xrange(20):</span>
<span class="c">#    t0 = time.time()</span>
<span class="c">#    d = bg.get()</span>
<span class="c">#    t2 = time.time()</span>
<span class="c">#    t  = t2 - t0</span>
<span class="c">#  #  logger.info(&#39;Start, Join, Popping   %.2f secs&#39; %t)</span>
<span class="c">#    CPU()</span>
<span class="c">#    t4 = time.time()</span>
<span class="c">#    t  = t4 - t2</span>
<span class="c">#    print(&#39;CPU task  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  t11 = time.time()</span>
<span class="c">#  total = (t11-t00)</span>
<span class="c">#  print(&#39;True time %.2f  sec, serial estimate %.2f&#39; %(total, serial))</span>
<span class="c">#  bg.shutdown()</span>
<span class="c">#</span>
<span class="c">#if False:</span>
<span class="c">#  Q = SharedQ(n_proc=1, dtype=np.uint8, shape=(1160, 480), default_target=IO, profile=False)</span>
<span class="c">#</span>
<span class="c">#  t00 = time.time()</span>
<span class="c">#  Q.startproc()</span>
<span class="c">#  for i in xrange(20):</span>
<span class="c">#    t0 = time.time()</span>
<span class="c">#    d = Q.get()</span>
<span class="c">#    t2 = time.time()</span>
<span class="c">#    t  = t2 - t0</span>
<span class="c">#  #  logger.info(&#39;Start, Join, Popping   %.2f secs&#39; %t)</span>
<span class="c">#    CPU()</span>
<span class="c">#    t4 = time.time()</span>
<span class="c">#    t  = t4 - t2</span>
<span class="c">#    print(&#39;CPU task  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  t11 = time.time()</span>
<span class="c">#  total = (t11-t00)</span>
<span class="c">#  print(&#39;True time %.2f  sec, serial estimate %.2f&#39; %(total, serial))</span>
<span class="c">#</span>
<span class="c">#  print &#39;\n\n\n\n&#39;</span>

<span class="c"># Process Approach ##########################################################################</span>
<span class="c">#if False:</span>
<span class="c">#  Q = SharedQ(0, np.uint8, (1160, 480))</span>
<span class="c">#</span>
<span class="c">#  t00 = time.time()</span>
<span class="c">#  mp_array, shape, _ = Q.puthandle()</span>
<span class="c">#  loader = mp.Process(target=IO, args=(mp_array, shape)) # start loading first item</span>
<span class="c">#  loader.start()</span>
<span class="c">#  for i in xrange(5):</span>
<span class="c">#    t0 = time.time()</span>
<span class="c">#</span>
<span class="c">#    loader.join()</span>
<span class="c">#    t1 = time.time()</span>
<span class="c">#    t  = t1 - t0</span>
<span class="c">#    print(&#39;Join Wait %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#    d = Q.get()</span>
<span class="c">#    t2 = time.time()</span>
<span class="c">#    t  = t2 - t1</span>
<span class="c">#  #  logger.info(&#39;Popping   %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#    mp_array, shape, _ = Q.puthandle()</span>
<span class="c">#    loader = mp.Process(target=IO, args=(mp_array, shape))</span>
<span class="c">#    loader.start()</span>
<span class="c">#    t3 = time.time()</span>
<span class="c">#    t  = t3 - t1</span>
<span class="c">#    print(&#39;Starting  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#    #CPUtask(d)</span>
<span class="c">#    CPU()</span>
<span class="c">#    t4 = time.time()</span>
<span class="c">#    t  = t4 - t3</span>
<span class="c">#    print(&#39;CPU task  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  t11 = time.time()</span>
<span class="c">#  total = (t11-t00)</span>
<span class="c">#  print(&#39;True time %.2f  sec, serial estimate %.2f&#39; %(total, serial))</span>

<span class="c"># [INFO/MainProcess] True time 5.95  sec, serial estimate 8.77</span>

<span class="c"># Threaded Approach #########################################################################</span>
<span class="c">#DataQ = deque()</span>
<span class="c">#</span>
<span class="c">#def IOtask():</span>
<span class="c">#  t0 =  time.time()</span>
<span class="c">#  d = load()</span>
<span class="c">#  DataQ.append(d)</span>
<span class="c">#  t = time.time() - t0</span>
<span class="c">#  logging.info(&#39;LOADED data in %.2f  sec&#39; %(t))</span>
<span class="c">#</span>
<span class="c">#class IOproc(th.Thread):</span>
<span class="c">#  def run(self):</span>
<span class="c">#    time.sleep(0.000001)</span>
<span class="c">#    t0 =  time.time()</span>
<span class="c">#    d = load()</span>
<span class="c">#</span>
<span class="c">#    DataQ.append(d)</span>
<span class="c">#    t = time.time() - t0</span>
<span class="c">#    logging.info(&#39;LOADED data in %.2f  sec&#39; %(t))</span>
<span class="c">#</span>
<span class="c">#class CPUproc(th.Thread):</span>
<span class="c">#  def run(self):</span>
<span class="c">#    time.sleep(0.000001)</span>
<span class="c">#    t0 =  time.time()</span>
<span class="c">#    a = np.random.rand(1160*480)</span>
<span class="c">#    for i in xrange(50):</span>
<span class="c">#      np.sin(a)</span>
<span class="c">#    t = time.time() - t0</span>
<span class="c">#    logging.info(&#39;LOADED data in %.2f  sec&#39; %(t))</span>
<span class="c">#</span>
<span class="c">#t00 = time.time()</span>
<span class="c">#loader = IOproc() # start loading first item</span>
<span class="c">#loader.start()</span>
<span class="c">#for i in xrange(5):</span>
<span class="c">#  t0 = time.time()</span>
<span class="c">#</span>
<span class="c">#  loader.join()</span>
<span class="c">#  t1 = time.time()</span>
<span class="c">#  t  = t1 - t0</span>
<span class="c">#  logging.info(&#39;Join Wait %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  d = DataQ.popleft()</span>
<span class="c">#  t2 = time.time()</span>
<span class="c">#  t  = t2 - t1</span>
<span class="c">#  logging.info(&#39;Popping   %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  #loader = th.Thread(target=IOtask, args=())</span>
<span class="c">#  loader = IOproc()</span>
<span class="c">#  loader.start()</span>
<span class="c">#  t3 = time.time()</span>
<span class="c">#  t  = t3 - t1</span>
<span class="c">#  logging.info(&#39;Starting  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  #CPUtask(d)</span>
<span class="c">#  cpu = CPUproc()</span>
<span class="c">#  cpu.start()</span>
<span class="c">#  cpu.join()</span>
<span class="c">#  t4 = time.time()</span>
<span class="c">#  t  = t4 - t3</span>
<span class="c">#  logging.info(&#39;CPU task  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#t11 = time.time()</span>
<span class="c">#total = (t11-t00)</span>
<span class="c">#serial = 5*rt + 5*lt</span>
<span class="c">#logging.info(&#39;True time %.2f  sec, serial estimate %.2f&#39; %(total, serial))</span>

<span class="c"># [INFO] (MainThread) True time 10.28  sec, serial estimate 8.68</span>

<span class="c"># Serial Approach #########################################################################</span>
<span class="c">#t00 = time.time()</span>
<span class="c">#for i in xrange(5):</span>
<span class="c">#  t0 = time.time()</span>
<span class="c">#  d  = load()</span>
<span class="c">#  t1 = time.time()</span>
<span class="c">#  t  = t1 - t0</span>
<span class="c">#  logging.info(&#39;Loading Wait %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#  CPUtask(d)</span>
<span class="c">#  t4 = time.time()</span>
<span class="c">#  t  = t4 - t1</span>
<span class="c">#  logging.info(&#39;CPU task  %.2f secs&#39; %t)</span>
<span class="c">#</span>
<span class="c">#t11 = time.time()</span>
<span class="c">#total = (t11-t00)</span>
<span class="c">#serial = 5*rt + 5*lt</span>
<span class="c">#logging.info(&#39;True time %.2f  sec, serial estimate %.2f&#39; %(total, serial))</span>

<span class="c"># [INFO] (MainThread) True time 8.93  sec, serial estimate 8.75</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Gregor Urban, Marius F Killinger.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
    </div>

    

    
  </body>
</html>